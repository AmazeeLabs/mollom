<?php

/**
 * @file
 * Testing functionality for Mollom module.
 *
 * @todo Extract testing server into a new mollom_test_server.module. The
 *   mollom_test.module serves as good example for how to implement Mollom
 *   support in a Drupal module, but 90% of it pertain to the testing server
 *   now, so it's hard to explain people what they should look at.
 */

/**
 * @defgroup mollom_test_xmlrpc Mollom XML-RPC fake server functions
 * @{
 */

/**
 * Implements hook_xmlrpc().
 */
function mollom_test_xmlrpc() {
  return array(
    // $data contains a variable amount of properties, so we cannot specify a
    // signature.
    'mollom.getServerList' => 'mollom_test_xmlrpc_get_server_list',
    'mollom.verifyKey' => 'mollom_test_xmlrpc_verify_key',
    'mollom.checkContent' => 'mollom_test_xmlrpc_check_content',
    'mollom.getImageCaptcha' => 'mollom_test_xmlrpc_get_captcha',
    'mollom.checkCaptcha' => 'mollom_test_xmlrpc_check_captcha',
    'mollom.sendFeedback' => 'mollom_test_xmlrpc_send_feedback',
 );
}

/**
 * Converts camelCase request/response parameters to lowercase with underscores.
 *
 * @todo Recurse into multi-dimensional arrays.
 */
function mollom_test_xmlrpc_convert_params(array $data = array()) {
  foreach ($data as $key => $value) {
    // Convert CamelCase to lowercase with underscores.
    $new_key = strtolower(preg_replace('@(?<=[a-z])([A-Z])@', '_$1', $key));
    $data[$new_key] = $value;
    unset($data[$key]);
  }
  return $data;
}

/**
 * XML-RPC callback for mollom.getServerList to retrieve new server list.
 */
function mollom_test_xmlrpc_get_server_list($data) {
  $servers = mollom_test_get_server_list($data);
  foreach ($servers as $key => $url) {
    $servers[$key] .= '/xmlrpc.php?version=';
  }
  return $servers;
}

/**
 * XML-RPC callback for mollom.verifyKey to validate API keys.
 */
function mollom_test_xmlrpc_verify_key($data) {
  $valid = mollom_test_verify_key($data);
  if ($valid) {
    return TRUE;
  }
  xmlrpc_error(Mollom::AUTH_ERROR);
}

/**
 * XML-RPC callback for mollom.checkContent to perform textual analysis.
 */
function mollom_test_xmlrpc_check_content($data) {
  return mollom_test_check_content($data);
}

/**
 * XML-RPC callback for mollom.getImageCaptcha to fetch a CATPCHA image.
 */
function mollom_test_xmlrpc_get_captcha($data) {
  return mollom_test_get_captcha($data);
}

/**
 * XML-RPC callback for mollom.checkCaptcha to validate a CAPTCHA response.
 */
function mollom_test_xmlrpc_check_captcha($data) {
  if (isset($data['captcha_result'])) {
    $data['solution'] = $data['captcha_result'];
  }

  return mollom_test_check_captcha($data);
}

/**
 * XML-RPC callback for mollom.sendFeedback to send feedback for a moderated post.
 */
function mollom_test_xmlrpc_send_feedback($data) {
  $result = mollom_test_send_feedback($data);
  if ($result) {
    return TRUE;
  }
  xmlrpc_error(Mollom::AUTH_ERROR);
}

/**
 * @} End of "defgroup mollom_test_xmlrpc".
 */

/**
 * @defgroup mollom_test_rest Mollom REST fake server functions
 * @{
 */

/**
 * Implements hook_menu() for REST API endpoints.
 */
function mollom_test_rest() {
  $path = 'mollom-test/rest/v1';
  $base_args = count(explode('/', $path)) - 1;
  // @todo Consider to use a generic page callback, passing arg(3), the resource
  //   type, and optionally arg(4), the resource, as argument. This would allow
  //   us to use PHP Exceptions to throw different status codes and errors. Make
  //   that page callback dynamically switch the delivery callback (for JSON).
  $base = array(
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'delivery callback' => 'mollom_test_rest_deliver',
  );

  $items[$path . '/site'] = $base + array(
    'page callback' => 'mollom_test_rest_site',
  );
  $items[$path . '/content'] = $base + array(
    'page callback' => 'mollom_test_rest_content',
  );
  $items[$path . '/captcha'] = $base + array(
    'page callback' => 'mollom_test_rest_captcha',
  );
  $items[$path . '/feedback'] = $base + array(
    'page callback' => 'mollom_test_rest_send_feedback',
  );
  $items[$path . '/blacklist/%'] = $base + array(
    'page callback' => 'mollom_test_rest_blacklist',
    'page arguments' => array($base_args + 2),
  );
  // @todo Whitelist endpoints.

  return $items;
}

/**
 * Returns HTTP request query parameters for the current request.
 *
 * @see Mollom::httpBuildQuery()
 * @see http://php.net/manual/en/wrappers.php.php
 */
function mollom_test_rest_get_parameters() {
  if ($_SERVER['REQUEST_METHOD'] == 'GET' || $_SERVER['REQUEST_METHOD'] == 'HEAD') {
    $data = Mollom::httpParseQuery($_SERVER['QUERY_STRING']);
  }
  elseif ($_SERVER['REQUEST_METHOD'] == 'POST' || $_SERVER['REQUEST_METHOD'] == 'PUT') {
    $data = Mollom::httpParseQuery(file_get_contents('php://input'));
  }
  return $data;
}

/**
 * Delivery callback for REST API endpoints.
 */
function mollom_test_rest_deliver($page_callback_result) {
  #drupal_add_http_header('Content-Type', 'application/xml; charset=utf-8');
  drupal_add_http_header('Content-Type', 'application/xml');

  $xml = new DOMDocument('1.0', 'utf-8');
  $element = $xml->createElement('response');

  // Append status response parameters.
  // @todo Add support for custom codes (redirect/refresh) + error messages.
  $code = 200;
  if (!is_array($page_callback_result) && $page_callback_result !== TRUE) {
    switch ($page_callback_result) {
      case MENU_NOT_FOUND:
        $code = 404;
        $message = 'Not found';
        break;

      case Mollom::AUTH_ERROR:
        $code = 1000;
        $message = 'Authentication failure';
        break;

      default:
        $code = 400;
        $message = 'Bad request';
        break;
    }
  }
  $status = array(
    'code' => $code,
  );
  if (isset($message)) {
    $status['message'] = $message;
  }
  mollom_test_rest_add_xml($xml, $element, $status);

  // Append other response parameters.
  if (is_array($page_callback_result)) {
    mollom_test_rest_add_xml($xml, $element, $page_callback_result);
  }

  $xml->appendChild($element);
  print $xml->saveXML();

  // Perform end-of-request tasks.
  drupal_page_footer();
}

function mollom_test_rest_add_xml(DOMDocument $doc, DOMNode $parent, $data, $key = NULL) {
  if (is_scalar($data)) {
    // Mollom REST API always uses integers instead of Booleans due to varying
    // implementations of JSON protocol across client platforms/frameworks.
    if (is_bool($data)) {
      $data = (int) $data;
    }

    $element = $doc->createTextNode($data);
    $parent->appendChild($element);
  }
  else {
    foreach ($data as $property => $value) {
      $key = (is_numeric($property) ? 'item' : $property);
      $element = $doc->createElement($key);
      $parent->appendChild($element);
      mollom_test_rest_add_xml($doc, $element, $value, $key);
    }
  }
}

/**
 * REST callback for CRUD site operations.
 *
 * @param $publicKey
 *   (optional) The public key of a site.
 * @param $delete
 *   (optional) Whether to delete the site with $publicKey.
 */
function mollom_test_rest_site($publicKey = NULL, $delete = FALSE) {
  $data = mollom_test_rest_get_parameters();

  // Prepare server list.
  $servers = mollom_test_get_server_list($data);
  foreach ($servers as $key => &$url) {
    $url .= '/mollom-test/rest/' . Mollom::API_VERSION;
  }

  $bin = 'mollom_test_site';
  $sites = variable_get($bin, array());

  // Check whether publicKey exists.
  if (isset($publicKey)) {
    if (!isset($sites[$publicKey])) {
      return MENU_NOT_FOUND;
    }
    // Validate authentication.
    $time = $data['time'];
    $nonce = $data['nonce'];
    $request_data = $time . ':' . $nonce . ':' . $sites[$publicKey]['privateKey'];
    $hash = base64_encode(hash_hmac('sha1', $request_data, $sites[$publicKey]['privateKey'], TRUE));
    if ($hash !== $data['hash']) {
      return Mollom::AUTH_ERROR;
    }
  }

  if ($_SERVER['REQUEST_METHOD'] == 'GET') {
    // Return existing site.
    if (isset($publicKey)) {
      $response = $sites[$publicKey];
    }
    // Return list of existing sites.
    else {
      $response = array(
        'list' => array_values($sites),
        'listCount' => count($sites),
        'listOffset' => 0,
        'listTotal' => count($sites),
      );
      return $response;
    }
  }
  else {
    // Update site.
    if (isset($publicKey) && !$delete) {
      // Remove authentication parameters.
      unset($data['publicKey'], $data['time'], $data['hash'], $data['nonce']);

      $storage = variable_get('mollom_test_verify_key', array());
      $storage[] = $data;
      variable_set('mollom_test_verify_key', $storage);

      $sites[$publicKey] = $data + $sites[$publicKey];
      variable_set($bin, $sites);
      $response = $sites[$publicKey];
    }
    // Create new site.
    // Authentication is ignored in this case.
    elseif (!$delete) {
      // Remove authentication parameters.
      unset($data['publicKey'], $data['time'], $data['hash'], $data['nonce']);

      $data['publicKey'] = $publicKey = md5(rand() . REQUEST_TIME);
      $data['privateKey'] = $privateKey = md5(rand() . REQUEST_TIME);
      // Apply default values.
      $data += array(
        'url' => '',
        'email' => '',
        'languages' => array(),
        'subscriptionType' => 0, // Mollom Free.
        // Client version info is not defined by default.
        /*
        'platformName' => '',
        'platformVersion' => '',
        'clientName' => '',
        'clientVersion' => '',
        */
        'servers' => $servers,
      );
      $sites[$publicKey] = $data;
      variable_set($bin, $sites);
      $response = $data;
    }
    // Delete site.
    else {
      unset($sites[$publicKey]);
      variable_set($bin, $sites);
      return TRUE;
    }
  }
  return array('site' => $response);
}

/**
 * REST callback for mollom.checkContent to perform textual analysis.
 */
function mollom_test_rest_content($contentId = NULL) {
  $data = mollom_test_rest_get_parameters();
  if ($_SERVER['REQUEST_METHOD'] == 'GET') {
    // @todo List/read content.
    if (empty($contentId)) {
      return FALSE;
    }
    return FALSE;
  }
  else {
    // Update existing content (includes sending feedback).
    // In case the 'moderated' parameter was passed, the call equals the old
    // mollom.sendFeedback and we only check whether the parameter value is
    // correct.
    if (isset($data['moderated'])) {
      $valid = is_string($data['moderated']);
      $valid = $valid && in_array($data['moderated'], array('spam', 'profanity', 'quality', 'unwanted', 'approve', 'escalate', 'delete', 'ignore'));
      return $valid;
    }
    // Content ID in request parameters must match the one in path.
    if (isset($data['id']) && $data['id'] != $contentId) {
      return FALSE;
    }
  }

  // Default POST: Create or update content and check it.
  return array('content' => mollom_test_check_content($data));
}

/**
 * REST callback to for CAPTCHAs.
 */
function mollom_test_rest_captcha($captchaId = NULL) {
  $data = mollom_test_rest_get_parameters();
  if ($_SERVER['REQUEST_METHOD'] == 'GET') {
    // There is no GET /captcha[/{captchaId}].
    return FALSE;
  }
  else {
    // CAPTCHA ID in request parameters must match the one in path.
    if (isset($data['id']) && $data['id'] != $captchaId) {
      return FALSE;
    }
    // Verify CAPTCHA.
    if (isset($data['id'])) {
      return array('captcha' => mollom_test_check_captcha($data));
    }
  }
  // Create a new CAPTCHA resource.
  return array('captcha' => mollom_test_get_captcha($data));
}

/**
 * REST callback for Blacklist API.
 *
 * @param $public_key
 *   The public key of a site.
 *
 * @todo Abstract actual functionality like other REST handlers.
 */
function mollom_test_rest_blacklist($public_key, $entryId = NULL, $delete = FALSE) {
  if (empty($public_key)) {
    return FALSE;
  }
  $data = mollom_test_rest_get_parameters();
  // Remove authentication parameters.
  unset($data['publicKey'], $data['time'], $data['hash'], $data['nonce']);

  // Prepare text value.
  if (isset($data['value'])) {
    $data['value'] = drupal_strtolower(trim($data['value']));
  }

  $bin = 'mollom_test_blacklist_' . $public_key;
  $entries = variable_get($bin, array());

  if ($_SERVER['REQUEST_METHOD'] == 'GET') {
    // List blacklist entries.
    if (empty($entryId)) {
      $response = array();
      // Remove deleted entries (== FALSE).
      $entries = array_filter($entries);
      $response['list'] = $entries;
      // @todo Not required yet.
      $response['listCount'] = count($entries);
      $response['listOffset'] = 0;
      $response['listTotal'] = count($entries);
      return $response;
    }
    // Read a single entry.
    else {
      // Check whether the entry exists and was not deleted.
      if (!empty($entries[$entryId])) {
        return array('entry' => $entries[$entryId]);
      }
      else {
        return MENU_NOT_FOUND;
      }
    }
  }
  else {
    // Update an existing entry.
    if (isset($entryId)) {
      // Entry ID must match.
      if (isset($data['id']) && $data['id'] != $entryId) {
        return FALSE;
      }
      // Check that the entry was not deleted.
      if (empty($entries[$entryId])) {
        return MENU_NOT_FOUND;
      }
      // Entry ID cannot be updated.
      unset($data['id']);
      $entries[$entryId] = $data;
      variable_set($bin, $entries);
      $response = $data;
      $response['id'] = $entryId;
      return array('entry' => $response);
    }
    // Create a new entry.
    elseif (!$delete) {
      $entryId = max(array_keys($entries)) + 1;
      $data['id'] = $entryId;
      $entries[$entryId] = $data;
      variable_set($bin, $entries);

      $response = $data;
      return array('entry' => $response);
    }
    // Delete an existing entry.
    else {
      // Check that the entry was not deleted already.
      if (!empty($entries[$entryId])) {
        $entries[$entryId] = FALSE;
        variable_set($bin, $entries);
        return TRUE;
      }
      else {
        return MENU_NOT_FOUND;
      }
    }
  }
}

/**
 * REST callback for mollom.sendFeedback to send feedback for a moderated post.
 */
function mollom_test_rest_send_feedback() {
  $data = mollom_test_rest_get_parameters();
  // A resource ID is required.
  if (empty($data['contentId']) && empty($data['captchaId'])) {
    return 400;
  }

  // The feedback is valid if the supplied reason is one of the supported
  // strings. Otherwise, it's a bad request.
  $result = mollom_test_send_feedback($data);
  return $result ? TRUE : 400;
}

/**
 * @} End of "defgroup mollom_test_rest".
 */

/**
 * API callback for mollom.getServerList to retrieve new server list.
 */
function mollom_test_get_server_list($data) {
  $storage = variable_get(__FUNCTION__, array());
  $storage[] = $data;
  variable_set(__FUNCTION__, $storage);

  return array($GLOBALS['base_url'], $GLOBALS['base_url']);
}

/**
 * API callback for mollom.verifyKey to validate API keys.
 */
function mollom_test_verify_key($data) {
  $storage = variable_get(__FUNCTION__, array());
  $storage[] = $data;
  variable_set(__FUNCTION__, $storage);

  module_load_include('inc', 'mollom');
  module_load_include('php', 'simpletest', 'drupal_web_test_case');
  module_load_include('test', 'mollom', 'tests/mollom');

  return $data['public_key'] === MOLLOM_TEST_PUBLIC_KEY;
}

/**
 * API callback for mollom.checkContent to perform textual analysis.
 *
 * @todo Add support for 'redirect' and 'refresh' values.
 */
function mollom_test_check_content($data) {
  $response = array();

  // If only a single value for checks is passed, it is a string.
  if (isset($data['checks']) && is_string($data['checks'])) {
    $data['checks'] = array($data['checks']);
  }

  // Fetch blacklist.
  $blacklist = variable_get('mollom_test_blacklist_' . $data['publicKey'], array());

  $post = implode('\n', array_intersect_key($data, array('postTitle' => 1, 'postBody' => 1)));

  // Spam filter: Check post_title and post_body for ham, spam, or unsure.
  if (!isset($data['checks']) || in_array('spam', $data['checks'])) {
    $spam = FALSE;
    $ham = FALSE;
    // 'spam' always has precedence.
    if (strpos($post, 'spam') !== FALSE) {
      $spam = TRUE;
    }
    // Otherwise, check for 'ham'.
    elseif (strpos($post, 'ham') !== FALSE) {
      $ham = TRUE;
    }
    // Lastly, take a forced 'unsure' into account.
    elseif (strpos($post, 'unsure') !== FALSE) {
      $spam = TRUE;
      $ham = TRUE;
    }
    // Check blacklist.
    if ($matches = mollom_test_check_content_blacklist($post, $blacklist, 'spam')) {
      $spam = TRUE;
      $ham = FALSE;
      $response['blacklistSpam'] = $matches;
    }

    if ($spam && $ham) {
      $response['spamScore'] = 0.5;
      $response['spamClassification'] = 'unsure';
      $qualityScore = 0.5;
    }
    elseif ($spam) {
      $response['spamScore'] = 1.0;
      $response['spamClassification'] = 'spam';
      $qualityScore = 0.0;
    }
    elseif ($ham) {
      $response['spamScore'] = 0.0;
      $response['spamClassification'] = 'ham';
      $qualityScore = 1.0;
    }
    else {
      $response['spamScore'] = 0.5;
      $response['spamClassification'] = 'unsure';
      $qualityScore = NULL;
    }
    // In case a previous spam check was unsure and a CAPTCHA was solved, the
    // result is supposed to be ham.
    $captcha_sessions = variable_get('mollom_test_check_captcha_sessions', array());
    if (!empty($data['captchaId']) && !empty($captcha_sessions[$data['captchaId']])) {
      $response['spamScore'] = 0.0;
      $response['spamClassification'] = 'ham';
    }
  }

  // Quality filter.
  if (!isset($data['checks']) || in_array('quality', $data['checks'])) {
    if (isset($qualityScore)) {
      $response['qualityScore'] = $qualityScore;
    }
    else {
      $response['qualityScore'] = 0;
    }
  }

  // Profanity filter.
  if (isset($data['checks']) && in_array('profanity', $data['checks'])) {
    $profanityScore = 0.0;
    if (strpos($post, 'profanity') !== FALSE) {
      $profanityScore = 1.0;
    }
    // Check blacklist.
    if ($matches = mollom_test_check_content_blacklist($post, $blacklist, 'profanity')) {
      $profanityScore = 1.0;
      $response['blacklistProfanity'] = $matches;
    }
    $response['profanityScore'] = $profanityScore;
  }

  // Language detection.
  if (isset($data['checks']) && in_array('language', $data['checks'])) {
    $languages = array();
    preg_match_all('@\blang-(..)\b@', $post, $matches);
    if (empty($matches[1])) {
      $languages[] = array(
        'languageCode' => 'zxx',
        'languageScore' => 1.0,
      );
    }
    elseif (count($matches[1]) > 3) {
      $languages[] = array(
        'languageCode' => LANGUAGE_NONE,
        'languageScore' => 1.0,
      );
    }
    else {
      $languageScore = 1 / count($matches[1]);
      foreach ($matches[1] as $language) {
        $languages[] = array(
          'languageCode' => $language,
          'languageScore' => $languageScore,
        );
      }
    }
    $response['languages'] = $languages;
    $response['langDebug'] = $matches;
  }

  $storage = variable_get(__FUNCTION__, array());
  $contentId = (!empty($data['id']) ? (int) $data['id'] : max(array_keys($storage)) + 1);
  $storage[$contentId] = $data;
  $response['id'] = $contentId;
  variable_set(__FUNCTION__, $storage);

  return $response;
}

/**
 * Checks a string against blacklisted terms.
 */
function mollom_test_check_content_blacklist($string, $blacklist, $reason) {
  $terms = array();
  foreach ($blacklist as $entry) {
    if ($entry['reason'] == $reason) {
      $term = preg_quote($entry['value']);
      if ($entry['match'] == 'exact') {
        $term = '\b' . $term . '\b';
      }
      $terms[] = $term;
    }
  }
  if (!empty($terms)) {
    $terms = '/(' . implode('|', $terms) . ')/';
    preg_match_all($terms, strtolower($string), $matches);
    return $matches[1];
  }
  return array();
}

/**
 * API callback for mollom.getImageCaptcha to fetch a CATPCHA image.
 */
function mollom_test_get_captcha($data) {
  $response = array();

  // Return a HTTPS URL if 'ssl' parameter was passed.
  $base_url = $GLOBALS['base_url'];
  if (!empty($data['ssl'])) {
    $base_url = str_replace('http', 'https', $base_url);
  }
  $response['url'] = $base_url . '/' . drupal_get_path('module', 'mollom') . '/images/powered-by-mollom-2.gif';

  $storage = variable_get(__FUNCTION__, array());
  $captchaId = (!empty($data['id']) ? (int) $data['id'] : max(array_keys($storage)) + 1);
  $storage[$captchaId] = $data;
  $response['id'] = $captchaId;
  variable_set(__FUNCTION__, $storage);

  return $response;
}

/**
 * API callback for mollom.checkCaptcha to validate a CAPTCHA response.
 *
 * @todo Add support for 'redirect' and 'refresh' values.
 */
function mollom_test_check_captcha($data) {
  $response = array();

  if (isset($data['solution']) && $data['solution'] == 'correct') {
    $response['solved'] = TRUE;
  }
  else {
    $response['solved'] = FALSE;
    $response['reason'] = '';
  }

  $storage = variable_get(__FUNCTION__, array());
  $captchaId = (!empty($data['id']) ? (int) $data['id'] : max(array_keys($storage)) + 1);
  $storage[$captchaId] = $data;
  $response['id'] = $captchaId;
  variable_set(__FUNCTION__, $storage);

  $captcha_sessions = variable_get('mollom_test_check_captcha_sessions', array());
  $captcha_sessions[$captchaId] = $response['solved'];
  variable_set('mollom_test_check_captcha_sessions', $captcha_sessions);

  return $response;
}

/**
 * API callback for mollom.sendFeedback to send feedback for a moderated post.
 */
function mollom_test_send_feedback($data) {
  $storage = variable_get(__FUNCTION__, array());
  $storage[] = $data;
  variable_set(__FUNCTION__, $storage);

  return in_array($data['reason'], array('spam', 'profanity', 'quality', 'unwanted', 'approve', 'delete'));
}

/**
 * Implements hook_menu().
 */
function mollom_test_menu() {
  $items = mollom_test_rest();

  $items['mollom-test/form'] = array(
    'title' => 'Mollom test form',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mollom_test_form'),
    'access callback' => TRUE,
  );
  return $items;
}

/**
 * Implements hook_forms().
 */
function mollom_forms() {
  $forms['mollom_basic_test_form'] = array(
    'callback' => 'mollom_test_form',
  );
  return $forms;
}

/**
 * Implements hook_mollom_form_list().
 */
function mollom_test_mollom_form_list() {
  $forms['mollom_test_form'] = array(
    'title' => 'Mollom test form',
    'entity' => 'mollom_test',
    'entity delete multiple callback' => 'mollom_test_delete_multiple',
    'moderation callback' => 'mollom_test_mollom_form_moderation',
  );
  // The basic test form is identical to the mollom_test_form, but only
  // registers minimal information (e.g., no entity or moderation callback) to
  // integrate with Mollom.
  $forms['mollom_basic_test_form'] = array(
    'title' => 'Mollom basic test form',
  );
  // Same as above, but supports elements for text analysis.
  $forms['mollom_basic_elements_test_form'] = array(
    'title' => 'Mollom basic elements test form',
  );
  return $forms;
}

/**
 * Implements hook_mollom_form_info().
 */
function mollom_test_mollom_form_info($form_id) {
  if ($form_id == 'mollom_basic_test_form') {
    return array();
  }
  $form_info = array(
    'bypass access' => array('administer mollom'),
    'elements' => array(
      'title' => 'Title',
      'body' => 'Body',
      'exclude' => 'Some other field',
      'parent][child' => 'Nested element',
      'field' => 'Multiple value field',
    ),
    'mapping' => array(
      'post_id' => 'mid',
      'post_title' => 'title',
      'author_name' => 'name',
    ),
  );
  return $form_info;
}

/**
 * Form builder for Mollom test form.
 */
function mollom_test_form($form, &$form_state, $mid = NULL) {
  // Due to #limit_validation_errors, submitting the form with the "Add" button
  // will only expose validated values in the submit handler, so our storage may
  // be incomplete. Therefore, the default values always have to be overloaded.
  $form_state += array('storage' => array());
  if (isset($mid) && ($record = mollom_test_load($mid))) {
    $form_state['storage'] = $record;
  }
  $form_state['storage'] += array(
    'mid' => $mid,
    'title' => '',
    'body' => '',
    'exclude' => '',
    'parent' => array('child' => ''),
    'field' => array(),
    'status' => 1,
  );
  // Always add an empty field the user can submit.
  $form_state['storage']['field']['new'] = '';

  $form['#tree'] = TRUE;
  $form['mid'] = array(
    '#type' => 'hidden',
    '#value' => $form_state['storage']['mid'],
  );
  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => 'Title',
    '#default_value' => $form_state['storage']['title'],
    '#required' => TRUE,
  );
  $form['body'] = array(
    '#type' => 'textfield',
    '#title' => 'Body',
    '#default_value' => $form_state['storage']['body'],
  );
  $form['exclude'] = array(
    '#type' => 'textfield',
    '#title' => 'Some other field',
    '#default_value' => $form_state['storage']['exclude'],
  );
  $form['parent']['child'] = array(
    '#type' => 'textfield',
    '#title' => 'Nested element',
    '#default_value' => $form_state['storage']['parent']['child'],
  );

  $form['field'] = array(
    '#type' => 'fieldset',
    '#title' => 'Field',
  );
  $weight = 0;
  foreach ($form_state['storage']['field'] as $delta => $value) {
    $form['field'][$delta] = array(
      '#type' => 'textfield',
      '#title' => 'Field ' . $delta,
      '#default_value' => $value,
      '#weight' => $weight++,
    );
  }
  $form['field']['new']['#weight'] = 999;
  $form['field']['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Add',
    '#limit_validation_errors' => array(array('field')),
    '#submit' => array('mollom_test_form_field_submit'),
    '#weight' => 1000,
  );

  $form['status'] = array(
    '#type' => 'checkbox',
    '#title' => 'Published',
    '#default_value' => $form_state['storage']['status'],
    // For simplicity, re-use Mollom module's administration permission.
    '#access' => user_access('administer mollom'),
  );

  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array('#type' => 'submit', '#value' => 'Submit');

  return $form;
}

/**
 * Form element submit handler for mollom_test_form().
 */
function mollom_test_form_field_submit($form, &$form_state) {
  // Remove internal Form API values.
  form_state_values_clean($form_state);
  // Remove all empty values of the multiple value field.
  $form_state['values']['field'] = array_filter($form_state['values']['field']);
  // Update the storage with submitted values.
  $form_state['storage'] = $form_state['values'];
  // Store the new value and clear out the 'new' field.
  if (isset($form_state['values']['field']['new'])) {
    $form_state['storage']['field'][] = $form_state['values']['field']['new'];
  }
  unset($form_state['input']['field']['new']);

  $form_state['rebuild'] = TRUE;
}

/**
 * Form submit handler for mollom_test_form().
 */
function mollom_test_form_submit($form, &$form_state) {
  $form_state['values']['field'][] = $form_state['values']['field']['new'];
  unset($form_state['values']['field']['new']);

  // Allow modules to alter the record before saving. This is done for code
  // consistency only.
  // @see mollom_mollom_test_presave()
  form_state_values_clean($form_state);
  module_invoke_all('mollom_test_presave', $form_state['values']);

  // Store submission.
  $update = !empty($form_state['values']['mid']) ? 'mid' : array();
  drupal_write_record('mollom_test', $form_state['values'], $update);

  // Redirect to stored entry.
  $form_state['redirect'] = 'mollom-test/form/' . $form_state['values']['mid'];

  drupal_set_message('Successful form submission.');
  drupal_set_message('<pre>' . var_export($form_state['values'], TRUE) . '</pre>');
}

/**
 * Implements hook_form_alter().
 */
function mollom_test_form_alter(&$form, &$form_state, $form_id) {
  if (variable_get('mollom_test_disable_mollom', FALSE)) {
    $form_state['mollom']['require_analysis'] = FALSE;
    $form_state['mollom']['require_captcha'] = FALSE;
  }
}

/**
 * Mollom form moderation callback for a mollom_test record.
 */
function mollom_test_mollom_form_moderation(&$form, &$form_state) {
  $form_state['values']['status'] = 0;
}

/**
 * Implements hook_mollom_test_presave() on behalf of mollom.module.
 */
function mollom_mollom_test_presave($record) {
  // If an existing record is published and we have session data stored for it,
  // mark the data as moderated.
  if (!empty($record['mid']) && $record['status']) {
    mollom_data_moderate('mollom_test', $record['mid']);
  }
}

/**
 * Loads a {mollom_test} data record by id.
 */
function mollom_test_load($mid) {
  return db_query('SELECT * FROM {mollom_test} WHERE mid = :mid', array(':mid' => $mid))->fetchAssoc();
}

/**
 * Deletes multiple stored {mollom_test} data records.
 *
 * @param $mids
 *   The mids to delete.
 */
function mollom_test_delete_multiple(array $mids) {
  db_delete('mollom_test')
    ->condition('mid', $mids)
    ->execute();
}
